// Generated by dts-bundle-generator v5.3.0

export declare namespace Enum {
	enum Type {
		Number = "number",
		String = "string"
	}
	function values<T = string | number>(anEnum: object): T[];
	function keys(anEnum: object): string[];
	function toObject(anEnum: object, keysAs?: Type): object;
	function length(anEnum: object): number;
	function isNumeric(anEnum: object): boolean;
	function isSequential(anEnum: object): boolean;
}
export declare type VoidFunction = () => void;
export declare type Function<T, U> = (value: T) => U;
export declare type AsyncFunction<T, U> = (value: T) => Promise<U>;
export declare type NullableFunction<T, U> = (value: T) => Nullable<U>;
export declare type OptionalFunction<T, U> = (value?: T) => U;
export declare type BiFunction<T, U, R> = (value1: T, value2: U) => R;
export declare type NullableBiFunction<T, U, R> = (value1: T, value2: U) => Nullable<R>;
export declare type OptionalBiFunction<T, U, R> = (value1?: T, value2?: U) => R;
export declare type Supplier<T> = () => T;
export declare type NullableSupplier<T> = () => Nullable<T>;
export declare type AsyncSupplier<T> = () => Promise<T>;
export declare type NullableAsyncSupplier<T> = () => Promise<Nullable<T>>;
export declare type BiSupplier<T, U> = () => [T, U];
export declare type Consumer<T> = (value: T) => void;
export declare type OptionalConsumer<T> = (value?: T) => void;
export declare type BiConsumer<T, U> = (value1: T, value2: U) => void;
export declare type OptionalBiConsumer<T, U> = (value1?: T, value2?: U) => void;
export declare type UnaryOperator<T> = (value: T) => T;
export declare type BinaryOperator<T> = (value1: T, value2: T) => T;
export declare type Predicate<T> = (value: T) => boolean;
export declare type BiPredicate<T, U> = (value1: T, value2: U) => boolean;
export declare type Comparator<T> = BiFunction<T, T, number>;
export declare type EqualityOperator<T> = BiFunction<T, T, boolean>;
export declare namespace Functions {
	function coerceBoolean(value: any): boolean;
	function isTruthy(value: any): boolean;
	function isFalsey(value: any): boolean;
	function noop(): void;
	function noopAsync(): Promise<void>;
	function noopAsyncReject(): Promise<never>;
}
export declare namespace Futures {
	function wait(ms: number): Promise<void>;
	function delayed(ms: number, callback: VoidFunction): Promise<void>;
	function waitUntil(condition: Supplier<boolean | Promise<boolean>>, waitInterval?: number): Promise<unknown>;
	function waitUntilResolved(timeout: number, condition: Supplier<boolean | Promise<boolean>>, waitInterval?: number): Promise<unknown>;
}
export declare class Latchable<T> {
	protected _value: T;
	protected _locked: boolean;
	private _isImmutable;
	constructor(value?: T);
	static immutable<T>(value?: T): Latchable<T>;
	latch(value: T): void;
	get value(): T;
}
export declare class Lockable<T> extends Latchable<T> {
	constructor(value?: T);
	set(value: T): void;
	offer(value: T, timeout?: number): Promise<void>;
	lock(): void;
	unlock(): void;
}
export declare namespace Objects {
	function nonNull<T = Record<string, any>>(input: T): Partial<T>;
	function nonUndefined<T = Record<string, any>>(input: T): Partial<T>;
	function truthy<T = Record<string, any>>(input: T): Partial<T>;
	function nonEmptyStrings<T = Record<string, any>>(input: T): Partial<T>;
	function drop<T, K extends keyof T>(input: T, ...keys: K[]): Partial<T>;
}
export declare enum BackoffStrategy {
	LINEAR = "LINEAR",
	FIBONACCI = "FIBONACCI",
	EXPONENTIAL = "EXPONENTIAL"
}
export declare class Backoff {
	private readonly strategy;
	private readonly maxWait;
	private readonly callable;
	private prevDelay;
	private nextDelay;
	constructor(strategy: BackoffStrategy, maxWait: number, callable: AsyncSupplier<boolean>);
	start(initialDelay?: number): Promise<void>;
	private next;
}
export declare type KeySet<T> = (keyof T)[];
export declare type WithLength = {
	length: number;
};
export declare type Nullable<T> = T | null | undefined;

export {};
