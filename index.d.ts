// Generated by dts-bundle-generator v5.9.0

export declare namespace Enum {
	enum Type {
		Number = "number",
		String = "string"
	}
	/**
	 * Gets an array of the enum values
	 *
	 * @export
	 * @template T type of key (string or number)
	 * @param {object} anEnum the enum object
	 * @returns {T[]} array of values
	 */
	function values<T = string | number>(anEnum: object): T[];
	/**
	 * Gets an array of the enum keys
	 *
	 * @export
	 * @param {object} anEnum the enum object
	 * @returns {string[]} array of keys
	 */
	function keys(anEnum: object): string[];
	/**
	 * Creates an object of key/value pairs from the enum. If the enum
	 * values are strings, then the original enum is returned (as it already is
	 * a key/value pair). If the enum values are numbers, the type value dictates
	 * whether the object is keyed with the enum's numeric value with the labels,
	 * or keyed with the labels with the numeric values
	 *
	 * @export
	 * @param {object} anEnum
	 * @param {Type} [keysAs=Type.Number]
	 * @return {*}  {object}
	 */
	function toObject(anEnum: object, keysAs?: Type): object;
	/**
	 * Gets the length of the enum's keys
	 *
	 * @export
	 * @param {object} anEnum the enum object
	 * @returns {number} count of elements
	 */
	function length(anEnum: object): number;
	/**
	 * Determine if an enum values are numeric
	 *
	 * @export
	 * @param {object} anEnum
	 * @return boolean
	 */
	function isNumeric(anEnum: object): boolean;
	/**
	 * Determine if an enum values are numeric and sequential
	 *
	 * @export
	 * @param {object} anEnum
	 * @return boolean
	 */
	function isSequential(anEnum: object): boolean;
}
/**
 * Represents a function that takes no arguments and returns no data
 */
export declare type VoidFunction = () => void;
/**
 * Represents a function that accepts one argument and produces a result.
 * @template T the parameter type
 * @template U the return type
 */
export declare type Function<T, U> = (value: T) => U;
/**
 * Represents a function that accepts one argument and produces a result asynchronously.
 * @template T the parameter type
 * @template U the return type
 */
export declare type AsyncFunction<T, U> = (value: T) => Promise<U>;
/**
 * Represents a function that accepts one argument and produces a result
 * that may be null or undefined.
 * @template T the parameter type
 * @template U the return type
 */
export declare type NullableFunction<T, U> = (value: T) => Nullable<U>;
/**
 * Represents a function that accepts one optional argument and produces a result.
 * @template T the parameter type
 * @template U the return type
 */
export declare type OptionalFunction<T, U> = (value?: T) => U;
/**
 * Represents a function that accepts two arguments and produces a result.
 * @template T the first argument type
 * @template U the second argument type
 * @template R the return type
 */
export declare type BiFunction<T, U, R> = (value1: T, value2: U) => R;
/**
 * Represents a function that accepts two arguments and produces a result
 * that may be null or undefined.
 * @template T the first argument type
 * @template U the second argument type
 * @template R the return type
 */
export declare type NullableBiFunction<T, U, R> = (value1: T, value2: U) => Nullable<R>;
/**
 * Represents a function that accepts two optional arguments and produces a result.
 * @template T the first argument type
 * @template U the second argument type
 * @template R the return type
 */
export declare type OptionalBiFunction<T, U, R> = (value1?: T, value2?: U) => R;
/**
 * Represents a supplier of a result.
 * @template T the return type
 */
export declare type Supplier<T> = () => T;
/**
 * Represents a supplier of a result that may be null or undefined.
 * @template T the return type
 */
export declare type NullableSupplier<T> = () => Nullable<T>;
/**
 * Represents a supplier of a promise.
 * @template T the return type
 */
export declare type AsyncSupplier<T> = () => Promise<T>;
/**
 * Represents a supplier of a promise whose resolved value may be
 * null or undefinded.
 * @template T the return type
 */
export declare type NullableAsyncSupplier<T> = () => Promise<Nullable<T>>;
/**
 * Represents a supplier of two results as a tuple.
 * @template T the first return type
 * @template U the second return type
 */
export declare type BiSupplier<T, U> = () => [
	T,
	U
];
/**
 * Represents an operation that accepts a single input argument
 * and returns no result.
 * @template T the argument type
 */
export declare type Consumer<T> = (value: T) => void;
/**
 * Represents an operation that accepts a single optional input argument
 * and returns no result.
 * @template T the argument type
 */
export declare type OptionalConsumer<T> = (value?: T) => void;
/**
 * Represents an operation that accepts two input arguments and returns no result.
 * @template T the first argument type
 * @template U the second argument type
 */
export declare type BiConsumer<T, U> = (value1: T, value2: U) => void;
/**
 * Represents an operation that accepts a optional arguments and returns no result.
 * @template T the first argument type
 * @template U the second argument type
 */
export declare type OptionalBiConsumer<T, U> = (value1?: T, value2?: U) => void;
/**
 * Represents an operation on a single operand that produces a
 * result of the same type as its operand.
 * @template T the type of the parameter and return type
 */
export declare type UnaryOperator<T> = (value: T) => T;
/**
 * Represents an operation upon two operands of the same type,
 * producing a result of the same type as the operands.
 * @template T the type of the parameter and return type
 */
export declare type BinaryOperator<T> = (value1: T, value2: T) => T;
/**
 * Represents a predicate (boolean-valued function) of one argument.
 * @template T the argument type
 */
export declare type Predicate<T> = (value: T) => boolean;
/**
 * Represents a predicate (boolean-valued function) of two arguments.
 * @template T the first argument type
 * @template U the second argument type
 */
export declare type BiPredicate<T, U> = (value1: T, value2: U) => boolean;
/**
 * Represents an operation that compares two operands of the same type
 * and produces a number (integer) for comparison purposes
 * @template T the argument type
 */
export declare type Comparator<T> = BiFunction<T, T, number>;
/**
 * Represents an operation that compares two operands of the same type
 * and produces a boolean result for comparison purposes
 * @template T the argument type
 */
export declare type EqualityOperator<T> = BiFunction<T, T, boolean>;
export declare namespace Functions {
	/**
	 * Coerces any value into a boolean value. If the value is a string,
	 * it will return true only if the string's value is true (case-insensitive)
	 *
	 * @export
	 * @param {*} value
	 * @return {*}  {boolean}
	 */
	function coerceBoolean(value: any): boolean;
	/**
	 * Checks if a value is truthy
	 *
	 * @export
	 * @param {*} value the value to test
	 * @return {*}  {boolean}
	 */
	function isTruthy(value: any): boolean;
	/**
	 * Checks if a value is falsey
	 *
	 * @export
	 * @param {*} value the value to test
	 * @return {*}  {boolean}
	 */
	function isFalsey(value: any): boolean;
	/**
	 * A function that takes no arguments and returns no result
	 *
	 * @export
	 */
	function noop(): void;
	/**
	 * A noop function that immediately resolves a promise. Useful for
	 * appeasing the TS compiler when a value is expected to be a Promise
	 *
	 * @export
	 * @returns {Promise<void>}
	 */
	function noopAsync(): Promise<void>;
}
/**
 * Futures is a namespace containing async functions
 * that serve as async/await wrappers around standard
 * setTimeout and setInterval functions
 */
export declare namespace Futures {
	/**
	 * Delay by a given amount of milliseconds. This is a
	 * Promise-based wrapper around setTimeout
	 *
	 * @export
	 * @param {number} ms the amount of milliseconds to wait
	 * @returns {Promise<void>}
	 */
	function wait(ms: number): Promise<void>;
	/**
	 * Delays execution of a function for a given amount of
	 * milliseconds. This is a Promise-based wrapper around
	 * setTimeout
	 *
	 * @export
	 * @param {number} ms the amount of milliseconds to wait
	 * @param {VoidFunction} callback
	 */
	function delayed(ms: number, callback: VoidFunction): Promise<void>;
	/**
	 * Waits until the provided condition is met. This will not resolve
	 * until the condition is true. To use a timeout or handle a condition
	 * that may return false, use Futures.waitUntilResolved instead
	 *
	 * @export
	 * @param {(Supplier<boolean | Promise<boolean>>)} condition the condition to be met
	 * @param {number} [pollInterval=1] the time in milliseconds between intervals
	 * @returns {*}  {Promise<void>}
	 */
	function waitUntil(condition: Supplier<boolean | Promise<boolean>>, pollInterval?: number): Promise<void>;
	/**
	 * Waits until the provided condition is met, then resolves
	 * unless the condition returns false or timeout is reached, then
	 * will reject. Use inside a try/catch
	 *
	 * @export
	 * @param {number} timeout the amount in milliseconds to wait
	 * @param {(Supplier<boolean | Promise<boolean>>)} condition the condition to be met
	 * @param {number} [pollInterval=1] the time in milliseconds between intervals
	 * @returns {*}  {Promise<void>}
	 */
	function waitUntilResolved(timeout: number, condition: Supplier<boolean | Promise<boolean>>, pollInterval?: number): Promise<void>;
	/**
	 * Calls an async supplier function and will attempt to return its resolved value within the
	 * allotted timeout. If the function does not resolve before the timeout expires, an error is thrown.
	 * If the function throws an error before the timeout expires, that error is thrown.
	 *
	 * @export
	 * @template T
	 * @param {number} timeout
	 * @param {AsyncSupplier<T>} runner
	 * @return {*}  {Promise<T>}
	 */
	function awaitWithTimeout<T>(timeout: number, runner: AsyncSupplier<T>): Promise<T>;
}
/**
 * A holder for a value that can be locked
 *
 * @export
 * @class Latchable
 * @template T the type of object to latch onto
 */
export declare class Latchable<T> {
	protected _value: T;
	protected _locked: boolean;
	private _isImmutable;
	constructor(value?: T);
	/**
	 * Creates an immutable instance that will freeze the
	 * value once provided
	 *
	 * @static
	 * @template T the type of the object to latch onto
	 * @param {T} [value] the value to latch
	 * @return {*}  {Latchable<T>} the new instance
	 * @memberof Latchable
	 */
	static immutable<T>(value?: T): Latchable<T>;
	/**
	 * Sets the value of the object and locks it
	 *
	 * @param {T} value the value to latch onto
	 * @memberof Latchable
	 */
	latch(value: T): void;
	/**
	 * The current value of the latched object
	 *
	 * @readonly
	 * @type {T}
	 * @memberof Latchable
	 */
	get value(): T;
}
export declare namespace Objects {
	type Keyable = string | number | symbol;
	/**
	 * Remove all object properties that are null or undefined,
	 * but retains falsey values such as empty strings or zero
	 *
	 * @export
	 * @template T
	 * @param {T} input the input object
	 * @return {*}  {(Partial<T> | T)}
	 */
	export function nonNull<T = Record<Keyable, any>>(input: T): Partial<T> | T;
	/**
	 * Remove all object properties that are undefined, but retains
	 * null properties and falsey values such as empty strings or zero
	 *
	 * @export
	 * @template T
	 * @param {T} input the input object
	 * @return {*}  {(Partial<T> | T)}
	 */
	export function nonUndefined<T = Record<Keyable, any>>(input: T): Partial<T> | T;
	/**
	 * Remove all object properties that are considered "falsey", which
	 * includes null, undefined, zero, false and empty strings, but retains
	 * empty arrays and objects
	 *
	 * @export
	 * @template T
	 * @param {T} input the input object
	 * @return {*}  {(Partial<T> | T)}
	 */
	export function truthy<T = Record<Keyable, any>>(input: T): Partial<T> | T;
	/**
	 * Remove all object properties that are empty (zero-length) strings, but retain
	 * all other values
	 *
	 * @export
	 * @template T
	 * @param {T} input
	 * @return {*}  {(Partial<T> | T)}
	 */
	export function nonEmptyStrings<T = Record<Keyable, any>>(input: T): Partial<T> | T;
	/**
	 * Creates a new object without the properties specified by keys
	 *
	 * @export
	 * @template T
	 * @template K
	 * @param {T} input the input object
	 * @param {...K[]} keys the properties to remove
	 * @return {*}  {(Partial<T> | T)}
	 */
	export function drop<T extends Record<Keyable, any>, K extends keyof T>(input: T, ...keys: K[]): Partial<T> | T;
	/**
	 * Map the result of a function to each entry's value in the object
	 *
	 * @export
	 * @template K
	 * @template V
	 * @template W
	 * @param {Record<K, V>} input the input object
	 * @param {BiFunction<Keyable, V, W>} cb the function to map new values, provides key k and value v
	 * @return {*}  {Record<K, W>}
	 */
	export function mapEntries<K extends Keyable, V, W = keyof K>(input: Record<K, V>, cb: BiFunction<Keyable, V, W>): Record<K, W>;
	export {};
}
export declare enum BackoffStrategy {
	/**
	 * LINEAR backoffs will increment one-by-one (1, 2, 3, 4, 5...)
	 */
	LINEAR = "LINEAR",
	/**
	 * FIBONACCI backoffs will use the fibonacci sequence (1, 2, 3, 5, 8...)
	 */
	FIBONACCI = "FIBONACCI",
	/**
	 * EXPONENTIAL backoffs will double the time since the last tick (1, 2, 4, 8, 16...)
	 */
	EXPONENTIAL = "EXPONENTIAL"
}
export interface BackoffOptions {
	/**
	 * The strategy to use to calculate the next tick
	 */
	strategy: BackoffStrategy;
	/**
	 * The function which determines when the backoff timer will stop
	 */
	callable: AsyncSupplier<boolean>;
	/**
	 * The maximum time that the backoff will continue before timing out (in seconds).
	 * This will throw an error when the timeout is reached
	 */
	maxWait?: number;
	/**
	 * The maximum interval between ticks (in seconds)
	 */
	maxInterval?: number;
	/**
	 * The initial delay until the first tick (in seconds)
	 */
	initialDelay?: number;
	/**
	 * A function that will be called on each tick
	 */
	onTick?: VoidFunction;
}
export declare class Backoff {
	private strategy;
	private callable;
	private prevDelay;
	private nextDelay;
	private maxInterval;
	private maxWait;
	private initialDelay;
	private onTick;
	/**
	 * Creates an instance of a Backoff circuit. Define a function (callable) to be called repeatedly until it
	 * resolves to true. Each time it resolves to false, the circuit will run again, the timing of which is governed
	 * by the BackoffStrategy
	 *
	 * @param {BackoffOptions} options the options object for this backoff instance
	 * @memberof Backoff
	 */
	constructor(options: BackoffOptions);
	/**
	 * Starts the backoff circuit
	 *
	 * @memberof Backoff
	 */
	start(): Promise<void>;
}
export declare type BindDecorator = (_: object, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
/**
 * Binds a class method to its instance using "this"
 *
 * @export
 * @template T
 * @returns {BindDecorator<T>}
 */
export declare function Bind(): BindDecorator;
export declare type KeySet<T> = (keyof T)[];
export declare type WithLength = {
	length: number;
};
export declare type Nullable<T> = T | null | undefined;

export {};
